<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="assets/style.css?t=90051322">
    <script src="assets/script.js?t=93f1a66c"></script>
    <title>Design Choices - Panko</title>
    <meta name="viewport" content="width=device-width">
  </head>
  <body class="-menu-visible">
    <div class="doc-layout">
      <div class="toggle menu-toggle js-menu-toggle"></div>
      <div class="menu toc-menu">
        <ul>
          <li class="menu-item -level-0 -parent">
            <ul class="submenu">
              <li class="menu-item -level-1"><a class="link title  link-index" href="index.html">Panko</a>
              </li>
              <li class="menu-item -level-1"><a class="link title  link-getting-started" href="getting-started.html">Getting Started</a>
              </li>
              <li class="menu-item -level-1 -parent"><span class="title">Reference</span>
                <ul class="submenu">
                  <li class="menu-item -level-2"><a class="link title  link-attributes" href="attributes.html">Attributes</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-associations" href="associations.html">Associations</a>
                  </li>
                  <li class="menu-item -level-2"><a class="link title  link-response-bag" href="response-bag.html">Response bag</a>
                  </li>
                </ul>
              </li>
              <li class="menu-item -level-1"><a class="link title  link-performance" href="performance.html">Performance</a>
              </li>
              <li class="menu-item -level-1"><a class="link title -active link-design-choices" href="design-choices.html">Design Choices</a>
                <ul class="headings heading-list">
                  <li class="heading-item -depth-2"><a class="hlink link-serialization-overview" href="#serialization-overview">Serialization overview</a>
                  </li>
                  <li class="heading-item -depth-2"><a class="hlink link-interesting-parts" href="#interesting-parts">Interesting parts</a>
                    <ul class="heading-list -depth-2">
                      <li class="heading-item -depth-3"><a class="hlink link-oj::stringwriter" href="#oj::stringwriter">Oj::StringWriter</a>
                      </li>
                      <li class="heading-item -depth-3"><a class="hlink link-figuring-out-the-metadata-ahead-of-time." href="#figuring-out-the-metadata-ahead-of-time.">Figuring out the metadata, ahead of time.</a>
                      </li>
                      <li class="heading-item -depth-3"><a class="hlink link-type-casting" href="#type-casting">Type Casting</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="body page-design-choices">
        <div class="header-nav">
          <div class="right"><a class="iconlink" href="https://github.com/yosiat/panko_serializer" data-title="yosiat/panko_serializer">
              <!-- span.title Open in GitHub--><span class="icon -github"></span></a>
          </div>
        </div>
        <div class="markdown-body"><h1 id="design-choices">Design Choices</h1>
<p>In short, Panko, is a serializer for ActiveRecord objects (it can&apos;t serialize any other object), which strives for high performance &amp; simple API (which is inspired by ActiveModelSerializers).</p>
<p>Its performance is achieved by:</p>
<ul>
<li><code>Oj::StringWriter</code> - I will elaborate later.</li>
<li>Type casting &#x2014; instead of relying on ActiveRecord to do its type cast, Panko is doing it by itself.</li>
<li>Figuring out the metadata, ahead of time &#x2014; therefore, we ask less questions during the <code>serialization loop</code>.</li>
</ul>
<h2 id="serialization-overview">Serialization overview</h2>
<p>First, let&apos;s start with overview. Let&apos;s say we want to serialize <code>User</code> object, which has
<code>first_name</code>, <code>last_name</code>, <code>age</code>, and <code>email</code> properties.</p>
<p>The serializer definition will be something like this:</p>
<pre><code class="lang-ruby"><span class="hljs-class"><span class="pl-k">class</span> <span class="pl-ent">UserSerializer</span> &lt; Panko::Serializer</span>
  attributes <span class="hljs-symbol">:name</span>, <span class="hljs-symbol">:age</span>, <span class="hljs-symbol">:email</span>
  
  <span class="hljs-function"><span class="pl-k">def</span> <span class="pl-ent">name</span></span>
    <span class="pl-s">&quot;<span class="hljs-subst">#{object.first_name}</span> <span class="hljs-subst">#{object.last_name}</span>&quot;</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span>
</code></pre>
<p>And the usage of this serializer will be:</p>
<pre><code class="lang-ruby"><span class="pl-c"># fetch user from database</span>
user = User.first

<span class="pl-c"># create serializer, with empty options</span>
serializer = UserSerilizer.new

<span class="pl-c"># serialize to JSON</span>
serializer.serialize_to_json(user)
</code></pre>
<p>Let&apos;s go over the steps that Panko will execute behind the scenes for this flow.
<em>I will skip the serializer definition part, because it&apos;s fairly simple and straightforward (see <code>lib/panko/serializer.rb</code>)</em></p>
<p>First step, while initializing the UserSerializer, we will create a <strong>Serialization Descriptor</strong> for this class.
Serialization Descriptor&apos;s goal is to answer those questions:</p>
<ul>
<li>Which fields do we have? In our case, <code>:age</code>, <code>:email</code></li>
<li>Which method fields do we have? In our case <code>:name</code></li>
<li>Which associations do we have (and their serialization descriptors)</li>
</ul>
<p>The serialization description is also responsible for filtering the attributes (<code>only</code> \ <code>except</code>).</p>
<p>Now, that we have the serialization descriptor, we are finished with the Ruby part of Panko, and all we did here is done in <em>initialization time</em> and now we move to C code.</p>
<p>In C land, we take the <code>user</code> object and the serialization descriptor, and start the serialization process which is separated to 4 parts:</p>
<ul>
<li>Serializing Fields - looping through serialization descriptor&apos;s <code>fields</code> and read them from the ActiveRecord object (see <code>Type Casting</code>) and write them to the writer.</li>
<li>Serializing Method Fields - creating (a cached) serializer instance, setting its <code>@object</code> and <code>@context</code>, calling all the method fields and writing them to the writer.</li>
<li>Serializing associations &#x2014; this is simple, once we have fields + method fields, we just repeat the process.</li>
</ul>
<p>Once this is finished, we have nice JSON string.
Now let&apos;s dig deeper.</p>
<h2 id="interesting-parts">Interesting parts</h2>
<h3 id="oj::stringwriter">Oj::StringWriter</h3>
<p>If you read the code of ActiveRecord serialization code in Ruby, you will observe this flow:</p>
<ol>
<li>Get an array of ActiveRecord objects (<code>User.all</code> for example)</li>
<li>Build new array of hashes where each hash is <code>User</code> with the attributes we selected</li>
<li>The JSON serializer, takes this array of hashes and loop them, and converts it to JSON string</li>
</ol>
<p>This entire process is expensive in terms of Memory &amp; CPU, and this where the combination of Panko and Oj::StringWriter really shines.</p>
<p>In Panko, the serialization process of the above is:</p>
<ol>
<li>Get an array of ActiveRecord objects (<code>User.all</code> for example)</li>
<li>Create <code>Oj::StringWriter</code> and feed the values to it, via <code>push_value</code> / <code>push_object</code> / <code>push_object</code> and behind the scene, <code>Oj::StringWriter</code> will serialize the objects incrementally into a string.</li>
<li>Get from <code>Oj::StringWriter</code> the completed JSON string &#x2014; which is a no-op, since <code>Oj::StringWriter</code> already built the string.</li>
</ol>
<h3 id="figuring-out-the-metadata-ahead-of-time.">Figuring out the metadata, ahead of time.</h3>
<p>Another observation I noticed in the ruby serializers is that they ask and do a lot in a serialization loop:</p>
<ul>
<li>Is this field a method? is it a property?</li>
<li>Which fields and associations do I need for the serializer to consider the <code>only</code> and <code>except</code> options</li>
<li>What is the serializer of this has_one association?</li>
</ul>
<p>Panko tries to ask the bare minimum in serialization by building <code>Serialization Descriptor</code> for each serialization and caching it.</p>
<p>The Serialization Descriptor will do the filtering of <code>only</code> and <code>except</code> and will check if a field is a method or not (therefore Panko doesn&apos;t have list of <code>attributes</code>)</p>
<h3 id="type-casting">Type Casting</h3>
<p>This is the final part, which helped yield most of the performance improvements.
In ActiveRecord, when we read a value of attribute, it does type casting of the DB value to its real ruby type.</p>
<p>For example, time strings are converted to Time objects, Strings are duplicated, and Integers are converts from their values to Number.</p>
<p>This type casting is really expensive, as it&apos;s responsible for most of the allocations in the serialization flow and most of them can be &quot;relaxed&quot;.</p>
<p>If we think about it, we don&apos;t need to duplicate strings or convert time strings to time objects or even parse JSON strings for the JSON serialization process.</p>
<p>What Panko does is that if we have ActiveRecord type string, we won&apos;t duplicate it.
If we have an integer string value, we will convert it to an integer, and the same goes for other types.</p>
<p>All of these conversions are done in C, which of course yields a big performance improvement.</p>
<h4 id="time-type-casting">Time type casting</h4>
<p>While you read Panko source code, you will encounter the time type casting and immediately you will have a &quot;WTF?&quot; moment.</p>
<p>The idea behind the time type casting code relies on the end result of JSON type casting &#x2014; what we need in order to serialize Time to JSON? UTC ISO8601 time format representation.</p>
<p>The time type casting works as follows:</p>
<ul>
<li>If it&apos;s a string that ends with <code>Z</code>, and the strings matches the UTC ISO8601 regex, then we just return the string.</li>
<li>If it&apos;s a string and it doesn&apos;t follow the rules above, we check if it&apos;s a timestamp in database format and convert it via regex + string concat to UTC ISO8601 - Yes, there is huge assumption here, that the database returns UTC timestamps &#x2014; this will be configureable (before Panko official release).</li>
<li>If it&apos;s none of the above, I will let ActiveRecord type casting do it&apos;s magic.</li>
</ul>

        </div>
        <div class="footer-nav">
          <div class="left"><a href="performance.html"><span class="title">Performance</span></a></div>
        </div>
      </div>
    </div>
  </body>
</html>